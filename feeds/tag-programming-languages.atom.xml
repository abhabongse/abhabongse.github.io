<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Personal Blog - programming languages</title><link href="https://abhabongse.github.io/" rel="alternate"></link><link href="https://abhabongse.github.io/feeds/tag-programming-languages.atom.xml" rel="self"></link><id>https://abhabongse.github.io/</id><updated>2020-03-31T00:00:00+07:00</updated><entry><title>On Fuzziness of Terminology: Compiling vs Interpreting</title><link href="https://abhabongse.github.io/posts/on-fuzziness-of-terminology-compiling-vs-interpreting/" rel="alternate"></link><published>2020-03-31T00:00:00+07:00</published><updated>2020-03-31T00:00:00+07:00</updated><author><name>Abhabongse Janthong</name></author><id>tag:abhabongse.github.io,2020-03-31:/posts/on-fuzziness-of-terminology-compiling-vs-interpreting/</id><summary type="html">&lt;p&gt;เมื่อเราต้องทำงานกับภาษาโปรแกรม (programming language) ภาษาต่าง&amp;hairsp;ๆ มากกว่า 1 ภาษา
เรามักจะพบว่าแต่ละภาษามีลักษณะที่แตกต่างกันออกไปเสมือนว่าแต่ละภาษาก็มีโลกเป็นของตัวเอง&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
หนึ่งในความแตกต่างทั้งหลายที่เห็นได้ชัดเจนที่สุดก็คือ
&amp;hairsp;&lt;em&gt;ลักษณะของภาษาที่จะทำงานแบบ compile หรือว่าแบบ interpret&lt;/em&gt;&amp;hairsp;&lt;/p&gt;&lt;p&gt;ก …&lt;/p&gt;</summary><content type="html">&lt;p&gt;เมื่อเราต้องทำงานกับภาษาโปรแกรม (programming language) ภาษาต่าง&amp;hairsp;ๆ มากกว่า 1 ภาษา
เรามักจะพบว่าแต่ละภาษามีลักษณะที่แตกต่างกันออกไปเสมือนว่าแต่ละภาษาก็มีโลกเป็นของตัวเอง&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
หนึ่งในความแตกต่างทั้งหลายที่เห็นได้ชัดเจนที่สุดก็คือ
&amp;hairsp;&lt;em&gt;ลักษณะของภาษาที่จะทำงานแบบ compile หรือว่าแบบ interpret&lt;/em&gt;&amp;hairsp;&lt;/p&gt;&lt;p&gt;ก่อนที่เราจะลงรายละเอียดเกี่ยวกับเรื่องนี้กัน ลองมาตอบคำถามต่อไปนี้ในใจก่อนครับ&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;ภาษาโปรแกรมต่อไปนี้ เป็นภาษาที่ทำงานแบบ &amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; หรือว่าแบบ &amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp;?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;C&amp;hairsp;/&amp;hairsp;C++&lt;/li&gt;&lt;li&gt;Java&lt;/li&gt;&lt;li&gt;Python&lt;/li&gt;&lt;li&gt;JavaScript&lt;/li&gt;&lt;li&gt;Ruby&lt;/li&gt;&lt;li&gt;Golang&lt;/li&gt;&lt;li&gt;Rust&lt;/li&gt;&lt;li&gt;OCaml&amp;hairsp;/&amp;hairsp;ReasonML&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(ไม่ได้กล่าวถึงภาษาโปรดของใครก็ขออภัยนะครับ 5&amp;thinsp;5&amp;thinsp;5&amp;thinsp;+)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;เรามาค่อย&amp;hairsp;ๆ ไขปริศนากับคำถามเหล่านี้ไปพร้อม&amp;hairsp;ๆ กันทีละสเต็ปกันครับ&lt;/p&gt;&lt;h2&gt;&lt;a class="headeranchor" id="bthsnthnaa-1-niyaamthiiphbaidthawaip"&gt;&lt;/a&gt;บทสนทนา 1:&amp;ensp;นิยามที่พบได้ทั่วไป&lt;a class="headerlink" href="#bthsnthnaa-1-niyaamthiiphbaidthawaip" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;นิยามของคำว่า &amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; กับ &amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp; ใน&amp;hairsp;&lt;em&gt;มุมมองของคนทั่วไป&lt;/em&gt;&amp;hairsp;มักมีลักษณะดังนี้&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;“&amp;hairsp;&amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; คือการที่เราต้องแปลงโค้ดจากที่เขียนไว้&amp;thinsp;ให้กลายเป็น
            executable file หรือ byte code ที่เราสามารถนำมารันต่อได้ภายหลัง&lt;/p&gt;&lt;p&gt;“เช่น การแปลงโค้ดภาษา C จากไฟล์ `*.c` ให้สุดท้ายกลายเป็นไฟล์ binary&lt;label for="sidenote-7feb1e4af970" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4af970" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
               ในกรณีนี้หมายรวมถึงทุกขั้นตอนในสายพานของการแปลงโค้ด
               ได้แก่ compile, assemble, link และ load&lt;/span&gt;
            ที่เราสามารถ execute ได้โดยตรง&lt;/p&gt;&lt;p&gt;“อีกตัวอย่างหนึ่งคือการ compile จาก Java source code ให้กลายเป็น Java bytecode
            ซึ่งจะถูกนำไปรันต่อด้วย Java virtual machine (JVM)&amp;hairsp;”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;“&amp;hairsp;&amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp; คือการที่เรามีตัวแปลภาษาที่รันคำสั่งแต่ละขั้นตอนตามลำดับได้ทันที
            โดยไม่จำเป็นต้องมีการแปลงไฟล์ก่อน&lt;/p&gt;&lt;p&gt;“เช่น การที่เรารันคำสั่ง JavaScript ได้จาก JavaScript console
           หรือเรารันคำสั่ง Python ได้จาก interactive shell หรือแม้แต่ Jupyter&amp;hairsp;”&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;แต่ว่านิยามข้างต้นมีข้อโต้แย้งจากตัวอย่างดังต่อไปนี้&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;ภาษา JavaScript สมัยใหม่ (เช่น EMCAScript 2015 เป็นต้นไป)
        สามารถรันได้โดยตรงโดยผ่าน NodeJS เวอร์ชันที่รองรับก็ได้ (ทำงานแบบ interpret ตามนิยามข้างต้น)&lt;/p&gt;&lt;p&gt;หรืออาจจะใช้ tool&lt;label for="sidenote-7feb1e4af8b0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4af8b0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;เช่น &lt;a href="https://babeljs.io/"&gt;BabelJS&lt;/a&gt;&lt;/span&gt;
        เพื่อช่วยแปลงโค้ดจาก EMCAScript เวอร์ชันใหม่&amp;hairsp;ๆ ไปยังเวอร์ชันที่เก่ากว่าที่สามารถรันภายใน browser ได้
        (ซึ่งเรียกว่า &amp;hairsp;&lt;strong&gt;source-to-source compilation&lt;/strong&gt;&amp;hairsp;)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;แล้วยิ่งเมื่อเราพูดถึงภาษา Python เราจะจัดให้เป็นภาษาแบบใด?&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        ก่อนที่เราจะลงรายละเอียดตรงนี้ เราไปดูบทสนทนาถัดไปกันต่อเลยครับ&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;a class="headeranchor" id="bthsnthnaa-2-tawyaangphaasaa-python"&gt;&lt;/a&gt;บทสนทนา 2:&amp;ensp;ตัวอย่างภาษา Python&lt;a class="headerlink" href="#bthsnthnaa-2-tawyaangphaasaa-python" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;“อ้าว ก็นี่ไง! เวลาเราเปิด Python interactive shell&lt;label for="sidenote-7feb1e4af6d0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4af6d0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
      เช่น การรันคำสั่ง &lt;code&gt;python&lt;/code&gt; ขึ้นมาโดยตรง หรืออาจจะเป็นการใช้งาน IPython/Jupyter ก็ได้
      ทั้งหมดนี้รวม&amp;hairsp;ๆ เรียกว่า REPL (read–eval–print–loop)&lt;/span&gt;
    ขึ้นมา
    ก็เห็นชัด&amp;hairsp;ๆ ว่ามันเป็น interpreter ที่รันคำสั่งภาษา Python ได้โดยตรงเลย&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
    &amp;hairsp;&lt;em&gt;ไม่เห็น&lt;/em&gt;&amp;hairsp;จะต้องแปลงโค้ด Python เป็นอย่างอื่นก่อนเลยแล้วจึงจะรันได้”&lt;/blockquote&gt;&lt;p&gt;ประเด็นอยู่ที่ว่า การที่โปรแกรมเมอร์ผู้ใช้งาน&amp;hairsp;&lt;u&gt;ไม่เห็น&lt;/u&gt;&amp;hairsp;โค้ดถูก compile ด้วยตาตัวเอง
ก็&amp;hairsp;&lt;strong&gt;ไม่ได้หมายความว่า&lt;/strong&gt;&amp;hairsp;ตัวโค้ด Python จะ&amp;hairsp;&lt;u&gt;ไม่เกิด&lt;/u&gt;&amp;hairsp;การ compile เสียหน่อย&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ในความเป็นจริงแล้วนั้น Python ที่ใช้กันทั่วไป&lt;label for="sidenote-7feb1e4af4f0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4af4f0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    ในกรณีนี้หมายถึง CPython implementation ของภาษา Python&lt;/span&gt;
จะมีขั้นตอนหนึ่งที่แปลงโค้ดจาก Python source code ให้กลายเป็น Python bytecode ก่อน&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
แล้วจากนั้นจึงมี Python runtime ตัวหนึ่ง&amp;thinsp;ที่คอยรันคำสั่งของ Python bytecode เหล่านั้นอีกทอดหนึ่ง&lt;/p&gt;&lt;blockquote&gt;“ก็ถูกแล้วนี่! สุดท้ายเราในฐานะโปรแกรมเมอร์ผู้ใช้งานก็รันโค้ด Python ได้โดยตรง
    ไม่ต้อง compile เอง เป็นไปตามนิยามที่ว่ามาข้างต้นเลย”&lt;/blockquote&gt;&lt;p&gt;ในความเป็นจริง&lt;a href="https://docs.python.org/3/library/py_compile.html"&gt;เราสามารถสร้าง bytecode จาก source code ของ Python เพื่อนำไปรันภายหลังได้&lt;/a&gt; (คล้ายกับภาษา Java)&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
แต่ interactive shell ของ Python ทำหน้าที่อำนวยความสะดวก (compile&amp;thinsp;+&amp;thinsp;execute) ให้กับโปรแกรมเมอร์เฉย&amp;hairsp;ๆ 
ซึ่งกระบวนการดังกล่าวไม่มีส่วนเกี่ยวข้องใด&amp;hairsp;ๆ กับสเปกของภาษา Python เอง&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“แต่สุดท้ายก็ต้องใช้ Python runtime เพื่อรันโค้ด python ทีละคำสั่งอยู่ดีนี่?
    ก็ต้องพูดได้สิว่า Python เป็นภาษาที่ทำงานแบบ interpret …&lt;/p&gt;&lt;p&gt;“แต่เดี๋ยวก่อนนะ! ถ้าแบบนี้เราก็ต้องจัดให้ Java เป็นภาษาแบบ interpret ด้วยเหมือนกันสิเนี่ยะ
    มันเกิดอะไรขึ้นเนี่ยะ?”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;ใช่แล้ว นั่นก็เพราะนิยามของคำว่า &amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; และ &amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp; ข้างต้นยังไม่รัดกุมพอ&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
เราจะมาลองให้นิยามของคำทั้ง 2 คำที่แม่นยำมากขึ้นกันในสเต็ปถัดไปกัน&lt;/p&gt;&lt;hr /&gt;&lt;h2&gt;&lt;a class="headeranchor" id="niyaamkhngkhamwaa-compile-aela-interpret"&gt;&lt;/a&gt;นิยามของคำว่า compile และ interpret&lt;a class="headerlink" href="#niyaamkhngkhamwaa-compile-aela-interpret" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ต่อไปนี้เป็นนิยามที่ถูกต้องของคำว่า compile และ interpret&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; คือการแปลงของโค้ดชุดหนึ่งไปยังโค้ดอีกชุดหนึ่ง
        ซึ่งอาจจะเปลี่ยนจากภาษาโปรแกรมภาษาหนึ่งไปยังอีกภาษาหนึ่งก็ได้
        หรือภาษาปลายทางจะยังคงเป็นภาษาเดิมก็ต่อ&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        แต่ประเด็นสำคัญคือโครงสร้างของโค้ด (syntax tree) ต้องเกิดการเปลี่ยนแปลงขึ้น
        จึงจะนับว่าเป็นการ compile&lt;label for="sidenote-7feb1e4afb20" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4afb20" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
            ฉะนั้นแล้ว code formatter อาจจะจัดว่าเป็นการ compile หรือไม่ก็ได้ ขึ้นกับกรณี&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ยกตัวอย่างเช่น การแปลงโค้ดภาษา C ให้กลายเป็น assembly code หรือ machine code&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        หรือการแปลง Java source code ให้กลายเป็น Java bytecode&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        หรือการแปลง EMCAScript 2015&amp;hairsp;+
        ให้กลายเป็น browser-compatible JavaScript&lt;label for="sidenote-7feb1e4afb80" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4afb80" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;โดยใช้ BabelJS เป็นต้น&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        และยังมีกรณีอื่น&amp;hairsp;ๆ อีกมากมาย&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp; คือการใช้ virtual machine (VM)
        เพื่อรันโค้ดบางอย่างบนเลเยอร์เหนือ machine ที่อยู่ระดับต่ำกว่า&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        เช่น การใช้ Python runtime&lt;label for="sidenote-7feb1e4afc40" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4afc40" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;คำว่า runtime นี้ถือว่าเป็น virtual machine อย่างหนึ่ง&lt;/span&gt;
        ในการรัน Python bytecode&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;hairsp;&lt;strong&gt;หมายเหตุ:&lt;/strong&gt;&amp;hairsp; หากเรากลับมาพิจารณาบทสนทนาแรกสุดอีกครั้งนึง จะพบว่า
&amp;thinsp;สิ่งที่แยกภาษา C และภาษา Java (ที่เชื่อว่าทำงานแบบ “compile”)
ออกจากภาษา Python (ที่เชื่อว่าทำงานแบบ “interpret”)
แท้จริงแล้วก็คือ&amp;hairsp;&lt;strong&gt;เวลา&lt;/strong&gt;&amp;hairsp;ที่โค้ดของโปรแกรมเหล่านั้นถูก compile และ execute ต่างหาก&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
กล่าวคือ&lt;/p&gt;&lt;ul&gt;&lt;li&gt;สำหรับภาษา C นั้น&amp;thinsp;เรานิยม compile โค้ดให้กลายเป็น executable binary ก่อน&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        แล้วหลังจากนั้นจึงมีการ execute โค้ดดังกล่าว
        ซึ่งอาจเกิดขึ้นเมื่อใดก็ได้ และกี่ครั้งก็ได้&lt;/li&gt;&lt;li&gt;ภาษา Java ก็เช่นกัน&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        สำหรับการนำโค้ด Java ไปใช้งาน
        เรามัก compile จาก Java source code ให้กลายเป็น bytecode ก่อน
        แล้วจึงนำ bytecode นี้ไปใช้งานจริงกับ JVM ภายหลัง&lt;/li&gt;&lt;li&gt;ในกรณีของภาษา Python นั้น&amp;thinsp;เรานิยมนำ Python source file ต้นฉบับ
        &amp;thinsp;เอาไปใช้งานจริงโดยตรง&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        ซึ่งโค้ดดังกล่าวจะถูก compile ให้กลายเป็น bytecode ทันที
        &amp;thinsp;ตอนที่โปรแกรมกำลังจะถูก execute ด้วย Python runtime เท่านั้น&lt;label for="sidenote-7feb1e4afdc0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4afdc0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
            ในบางกรณี อาจมีการแคช bytecode ที่ถูกสร้างขึ้นนี้ในรูปของไฟล์ &lt;code&gt;*.pyc&lt;/code&gt; อีกด้วย&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;h2&gt;&lt;a class="headeranchor" id="bthsnthnaa-3-swmhmwknakptibatiniym"&gt;&lt;/a&gt;บทสนทนา 3:&amp;ensp;สวมหมวกนักปฏิบัตินิยม&lt;a class="headerlink" href="#bthsnthnaa-3-swmhmwknakptibatiniym" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;“เนี่ยะ เวลาโปรแกรมเมอร์ใช้คำว่า compile กับ interpret เนี่ยะ
    เรากำลังพูดถึงว่า เราต้องเอาโค้ดไป compile ก่อนใช้งานหรือเปล่า
    หรือว่าเราเอาโค้ดนี้ไป interpret กันหน้างานเลย&amp;hairsp;…&lt;/p&gt;&lt;p&gt;“จากมุมมองนี้ แล้วมันผิดตรงไหนที่เราจะบอกว่า Java เป็นภาษาแบบ compile
    และ Python เป็นภาษาแบบ interpret?”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;ผู้เขียนเห็นด้วยในมุมมองที่ว่า หากเราสามารถหาวิธีใช้สื่อสารที่บรรลุผลตามที่ต้องการ ก็ถือว่าเป็นอันใช้ได้&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ไม่สนับสนุนให้มีใครมากำหนดว่า&amp;thinsp;คำอะไรสามารถใช้งานแบบไหนได้บ้าง&amp;thinsp;หรือไม่ได้บ้าง&lt;label for="sidenote-7feb1e4afee0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4afee0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    ผู้เขียนไม่ใช่นักภาษาศาสตร์และไม่รู้เรื่องภาษาศาสตร์เพียงพอที่จะแสดงความคิดเห็นเกี่ยวกับเรื่องนี้ได้
    เอาพอแค่นี้ก่อนละกัน เดี๋ยวมีภาษาศาสตร์ผ่านมาหวด&lt;/span&gt;&lt;/p&gt;&lt;p&gt;แต่ในขณะเดียวกัน หากเราพยายามชี้ชัดว่า&amp;thinsp;ภาษาโปรแกรมภาษานั้นหรือภาษานี้
จะต้องทำงานแบบ compile หรือว่า interpret &amp;hairsp;&lt;em&gt;อย่างใดอย่างหนึ่ง&lt;/em&gt;&amp;hairsp;ไปเสียหมด&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
นั่นก็อาจคาดเคลื่อนจากความเป็นจริงก็ได้ นั่นก็เพราะว่า
&amp;hairsp;&lt;em&gt;ภาษาโปรแกรมหลายภาษา&lt;/em&gt;&amp;hairsp; จะนำโค้ดไป &amp;hairsp;&lt;strong&gt;compile ก่อนใช้งาน&lt;/strong&gt;&amp;hairsp;ก็ได้
หรือจะ&amp;hairsp;&lt;strong&gt;เอาไปใช้งานโดยตรงในทันที&lt;/strong&gt;&amp;hairsp;เลยก็ได้&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ตัวอย่างที่ชัดเจนที่สุดก็คือโค้ดที่เขียนตามมาตรฐานใหม่ของ JavaScript&lt;label for="sidenote-7feb1e4b21f0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b21f0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
            จำพวก EMCAScript 2015&amp;hairsp;+ เป็นต้น&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        ซึ่งเราอาจจะนำมารันโดยตรงด้วย NodeJS เลยก็ได้&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        หรืออาจจะใช้ BabelJS เพื่อ compile ให้กลายเป็น JavaScript
        เวอร์ชันที่สามารถรันภายใน browser ก็ได้เช่นกัน&lt;/li&gt;&lt;li&gt;&lt;p&gt;อีกตัวอย่างหนึ่งคือภาษา &lt;a href="https://ocaml.org/"&gt;OCaml&lt;/a&gt;&lt;label for="sidenote-7feb1e4b22b0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b22b0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
            และรวมถึงภาษา &lt;a href="https://reasonml.github.io/"&gt;ReasonML&lt;/a&gt; ที่เป็นพี่น้องด้วย&lt;/span&gt;
        ซึ่งมีหลาย option ให้เลือกดังต่อไปนี้&lt;/p&gt;&lt;ol&gt;&lt;li&gt;สามารถ &lt;a href="https://caml.inria.fr/pub/docs/manual-ocaml/comp.html"&gt;compile โค้ดให้เป็น bytecode&lt;/a&gt;
                แล้วจึง&lt;a href="https://caml.inria.fr/pub/docs/manual-ocaml/runtime.html"&gt;รันด้วย runtime&lt;/a&gt; ก็ได้&lt;/li&gt;&lt;li&gt;หรือจะ &lt;a href="https://caml.inria.fr/pub/docs/manual-ocaml/native.html"&gt;compile ให้เป็น machine code&lt;/a&gt; ก็ได้&lt;/li&gt;&lt;li&gt;ไม่เพียงแค่นั้น ปัจจุบันมี OCaml implementation ชื่อว่า
                &lt;a href="https://bucklescript.github.io/"&gt;BuckleScript&lt;/a&gt;
                ที่สามารถ compile โค้ด OCaml ให้รันบน JavaScript ได้อีกด้วย&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;a class="headeranchor" id="khlaaypm"&gt;&lt;/a&gt;คลายปม&lt;a class="headerlink" href="#khlaaypm" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;เพื่อคลายข้อสงสัย ขอเฉลย ณ ตรงนี้ว่า&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
คำว่า compile และ interpret แท้จริงแล้ว&amp;hairsp;&lt;em&gt;ไม่ได้&lt;/em&gt;&amp;hairsp;เอาไว้อธิบายตัวภาษาโปรแกรมโดยตรง 
&amp;hairsp;&lt;strong&gt;แต่เอาไว้อธิบาย implementation หนึ่ง&amp;hairsp;ๆ ของภาษาโปรแกรมต่างหาก&lt;/strong&gt;&amp;hairsp;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ไม่ใช่เรื่องแปลกที่ภาษาโปรแกรมภาษาเดียวกัน&amp;hairsp;จะมี implementation ที่หลากหลายแตกต่างกันออกไป&lt;/p&gt;&lt;p&gt;ข้อสังเกตอย่างหนึ่งที่ผู้เขียนพบคือ เวลาโปรแกรมเมอร์พูดถึงภาษาโปรแกรมภาษาหนึ่ง
เราอาจกำลังหมายถึง ecosystem ของภาษานั้น&amp;hairsp;ๆ เสียมากกว่า
(เช่น เวลาพูดถึง Python อาจจะหมายถึง CPython implementation ที่เป็นที่นิยม
ซึ่งพูดรวมไปถึง Python language, Python bytecode, Python runtime เป็นต้น)&lt;label for="sidenote-7feb1e4b2610" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2610" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    ดูเพิ่มเติม &lt;a href="https://glossary.sil.org/term/metonymy"&gt;metonymy&lt;/a&gt;&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
จึงเป็นเหตุให้เราใช้คำว่า compile หรือ interpret อย่างที่พบในปัจจุบัน&lt;/p&gt;&lt;p&gt;&amp;hairsp;&lt;strong&gt;บทแทรก:&lt;/strong&gt;&amp;hairsp; จนถึงตรงนี้ ผู้เขียนใช้คำว่า Python bytecode ในบทความหลายครั้ง&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ในความเป็นจริงแล้ว Python bytecode ที่พูดถึงนี้&amp;thinsp;เป็นเพียง 
implementation detail ของ CPython ecosystem เท่านั้น
ไม่ถือว่าเป็นส่วนหนึ่งของ Python ภาษาหลักแต่อย่างใด&lt;label for="sidenote-7feb1e4b2730" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2730" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    implementation อื่นของ Python อย่างเช่น 
    &lt;a href="https://pypy.readthedocs.io/en/latest/interpreter.html"&gt;PyPy&lt;/a&gt;
    ก็มี bytecode ของตัวเองเช่นกัน&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
    แต่ว่าเป็น&amp;hairsp;&lt;em&gt;คนละตัว&lt;/em&gt;&amp;hairsp;กับของ CPython&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;a class="headeranchor" id="bthsnthnaa-4-static-type-checking"&gt;&lt;/a&gt;บทสนทนา 4:&amp;ensp;static type checking&lt;a class="headerlink" href="#bthsnthnaa-4-static-type-checking" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;อีกปัจจัยหนึ่งที่ผู้คนมักนำมาเชื่อมโยงกับการจำแนกภาษาที่ทำงานแบบ compile หรือ interpret
ก็คือ static type checking&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“อย่างที่รู้กันอยู่แล้วว่า ภาษาที่มีการ compile อย่างภาษา C หรือ Java
    จะมีการตรวจสอบ type ของค่าต่าง&amp;hairsp;ๆ ภายในโปรแกรมระหว่างโปรแกรมกำลัง compile&lt;/p&gt;&lt;p&gt;“แล้วทำไมภาษา Python ถึงทำไม่ได้? ทั้ง&amp;hairsp;ๆ ที่มีการ compile ด้วยเหมือนกัน
    &amp;thinsp;หรือว่านิยามใหม่ของคำว่า compile ที่เสนอมาจะใช้ไม่ได้แล้วล่ะมั้ง&amp;hairsp;…&lt;/p&gt;&lt;p&gt;“นี่ขนาดภาษา JavaScript ยังต้องมีการ extend syntax กลายเป็นภาษาใหม่อย่าง TypeScript&lt;label for="sidenote-7feb1e4b2970" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2970" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
        แน่นอนว่า TypeScript ไม่ใช่ JavaScript เพราะเป็น superset ของ JavaScript&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        นั่นหมายความว่าโค้ดบางอย่างใน TypeScript ไม่ใช่ valid JavaScript&lt;/span&gt;
    เพื่อแก้ปัญหาเรื่อง static type check เลย”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;แม้ว่า static type checking จะมีความเกี่ยวข้องกับ code compilation&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
แต่ก็&amp;hairsp;&lt;em&gt;ไม่จำเป็น&lt;/em&gt;&amp;hairsp;ที่ทั้งสองอย่างนี้จะต้องมาคู่กันเสมอไป&lt;/p&gt;&lt;p&gt;ก่อนอื่น อย่างที่ทราบกันดีว่า static type checking ที่เกิดขึ้นระหว่างที่โปรแกรมกำลัง compile นั้น
จะช่วยทำให้เรามั่นใจได้ว่า&amp;thinsp;การรันโปรแกรมที่ compile แล้ว
จะไม่เกิด error อันเกิดจาก type ที่ผิดพลาดได้อีก&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
และจึง&amp;hairsp;&lt;em&gt;ไม่จำเป็น&lt;/em&gt;&amp;hairsp;ที่โปรแกรมต้องตรวจสอบความถูกต้องของ type ระหว่างที่รันโปรแกรมอีก&lt;label for="sidenote-7feb1e4b2a30" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2a30" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    และอาจเกิดการทำ type erasure ได้ด้วย&lt;/span&gt;&lt;/p&gt;&lt;p&gt;แต่ว่าอันที่จริงแล้ว implementation ของภาษาหนึ่ง&amp;hairsp;ๆ ก็สามารถเลือกที่จะโยกย้าย type checking
จากตอน compilation time ไปยังตอน execution time ของโปรแกรมได้&lt;label for="sidenote-7feb1e4b2a90" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2a90" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;ยกเว้นบางกรณี&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
นั่นหมายความว่า compiler ไม่จำเป็นว่าจะต้องมี type checking ในทุกกรณีเสมอไป&lt;label for="sidenote-7feb1e4b2af0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2af0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    สังเกตว่าในบางกรณีของ JavaScript to JavaScript compiler อย่าง BabelJS
    ก็ไม่มีการตรวจสอบ type เช่นกัน ก็ถือว่าเป็น compiler&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;hairsp;&lt;strong&gt;หมายเหตุ:&lt;/strong&gt;&amp;hairsp; ในปัจจุบัน Python 3.5&amp;hairsp;+ รองรับการกำหนด type ให้แก่ค่าต่าง&amp;hairsp;ๆ ในโค้ดได้
(เรียกว่า type annotation)&lt;label for="sidenote-7feb1e4b2bb0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2bb0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;อ่านรายละเอียดของ
    &lt;a href="https://docs.python.org/3/library/typing.html"&gt;type annotation&lt;/a&gt; ได้&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ซึ่งโปรแกรมเมอร์ผู้ใช้งานสามารถเลือกที่จะ annotate type ให้แก่ค่าบางค่าในโค้ด
หรือจะทั้งหมดของโค้ดก็ได้&lt;label for="sidenote-7feb1e4b2c10" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2c10" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    ตอนนี้มีเครื่องมืออย่าง &lt;a href="http://mypy-lang.org/"&gt;mypy&lt;/a&gt; ที่สามารถใช้ข้อมูล type annotation
    เพื่อช่วยเหลือโปรแกรมเมอร์ผู้ใช้งานในการตรวจสอบความถูกต้องของ type ในโปรแกรมได้&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
แต่ CPython implementation จะไม่นำข้อมูลเกี่ยวกับ type เหล่านี้มาช่วยทำ type checking
ตอนรันโปรแกรมแต่อย่างใด&lt;label for="sidenote-7feb1e4b2cd0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2cd0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    แต่ type checking ตอน execution time แบบเดิมยังเกิดขึ้นตามปกติ&lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ในอนาคตอาจจะมี implementation ของ python ตัวใหม่ที่จะอนุญาตให้โค้ด compile ผ่าน
ก็ต่อเมื่อโปรแกรมผ่านการตรวจสอบ type เท่านั้น ก็เป็นได้&lt;/p&gt;&lt;h2&gt;&lt;a class="headeranchor" id="bthsnthnaa-5-khngaebbniiekhaaduukantncchbekm"&gt;&lt;/a&gt;บทสนทนา 5:&amp;ensp;ของแบบนี้เค้าดูกันตอนจบเกม&lt;a class="headerlink" href="#bthsnthnaa-5-khngaebbniiekhaaduukantncchbekm" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;“ถึงแม้จะพยายามบอกว่าคำว่า compile กับ interpret เอาไว้ใช้อธิบาย implementation ของภาษาก็ตามที&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
    แต่เอาจริง&amp;hairsp;ๆ ไหม? ทำไมเราไม่ดูล่ะว่าภาษานั้น&amp;hairsp;ๆ สามารถแปลงให้กลายเป็น machine code ได้เลย
    หรือว่าจำเป็นต้องมี virtual machine มารันโปรแกรมนั้น ไม่ทางใดก็ทางหนึ่ง&lt;/p&gt;&lt;p&gt;“พูดง่าย&amp;hairsp;ๆ คือเราตัดสินกันนี่แหละว่าภาษาทำงานแบบ compile หรือ interpret โดยดูจากว่า
    โค้ดจะถูกรันโดย physical machine โดยตรง หรือว่าจะถูกรันด้วย virtual machine กันแน่”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;ประเด็นนี้สามารถโต้แย้งได้ง่ายมาก โดยดูจากตัวอย่างค้านจากภาษา OCaml/ReasonML
ที่ได้กล่าวถึงไปแล้วก่อนหน้านี้&lt;/p&gt;&lt;p&gt;นอกเหนือจากนั้น บทสนทนาดังกล่าวได้แสดงถึงความพยายามที่จะสร้างเส้นสมมติ
เพื่อแบ่ง virtual machine ออกจาก physical machine 
โดยฝืนธรรมชาติของความหมายของคำว่า &amp;hairsp;&lt;strong&gt;machine&lt;/strong&gt;&amp;hairsp; อย่างมาก
ในบริบทของการศึกษาเกี่ยวกับระบบและสถาปัตยกรรมคอมพิวเตอร์&lt;/p&gt;&lt;p&gt;แท้ที่จริงแล้ว code ของโปรแกรมไม่ว่าอยู่ในรูปแบบหรือภาษาใด&amp;hairsp;ๆ ก็ย่อมต้องการ machine ในการรันทั้งสิ้น&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
สังเกตว่า physical machine นั้นทำหน้าที่ไม่ได้แตกต่างจาก virtual machine เลย 
(ซึ่งก็คือการรันโค้ดเหมือน&amp;hairsp;ๆ กัน)&lt;label for="sidenote-7feb1e4b2eb0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b2eb0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;เราอาจเรียกว่า code และ machine เป็นของที่คู่กันก็ว่าได้&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ฉะนั้นในบริบทนี้&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt; virtual machine และ physical machine
เห็นจะแตกต่างกันแต่เพียง&amp;hairsp;&lt;strong&gt;ระดับชั้นนามธรรม (layers of abstraction)&lt;/strong&gt;&amp;hairsp; ก็เท่านั้นเอง&lt;/p&gt;&lt;p&gt;&amp;hairsp;&lt;strong&gt;บทแทรก:&lt;/strong&gt;&amp;hairsp; สมมติว่าเรามีโปรแกรมอันหนึ่ง ที่มีส่วนประกอบดังต่อไปนี้&lt;/p&gt;&lt;ul&gt;&lt;li&gt;โค้ด &lt;span class="math-inline"&gt;C&lt;/span&gt; ที่เขียนด้วยภาษา &lt;span class="math-inline"&gt;X_0&lt;/span&gt;&lt;/li&gt;&lt;li&gt;runtime &lt;span class="math-inline"&gt;R_0&lt;/span&gt; สำหรับภาษา &lt;span class="math-inline"&gt;X_0&lt;/span&gt; ที่เขียนด้วยภาษา &lt;span class="math-inline"&gt;X_1&lt;/span&gt;&lt;/li&gt;&lt;li&gt;runtime &lt;span class="math-inline"&gt;R_1&lt;/span&gt; สำหรับภาษา &lt;span class="math-inline"&gt;X_1&lt;/span&gt; ที่เขียนด้วยภาษา &lt;span class="math-inline"&gt;X_2&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class="math-inline"&gt;\ldots&lt;/span&gt;&lt;/li&gt;&lt;li&gt;runtime &lt;span class="math-inline"&gt;R_{n-1}&lt;/span&gt; สำหรับภาษา &lt;span class="math-inline"&gt;X_{n-1}&lt;/span&gt; ที่เขียนด้วยภาษา &lt;span class="math-inline"&gt;X_n&lt;/span&gt;&lt;/li&gt;&lt;li&gt;และ runtime &lt;span class="math-inline"&gt;R_n&lt;/span&gt; สำหรับภาษา &lt;span class="math-inline"&gt;X_n&lt;/span&gt; ที่เขียนด้วย machine language&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;เราจะสามารถพูดได้ว่าการนำโค้ด &lt;span class="math-display"&gt;C^* := C+R_0+R_1+\ldots+R_n&lt;/span&gt; ทั้งหมดมารวมกัน
จะถือว่า &lt;span class="math-inline"&gt;C^*&lt;/span&gt; เป็นโค้ดที่เขียนด้วย machine language โดยตรงก็ได้&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
เพราะว่าในมุมมองของ machine การรันโค้ด &lt;span class="math-inline"&gt;C^*&lt;/span&gt;
นั้น&amp;hairsp;&lt;em&gt;ไม่แตกต่าง&lt;/em&gt;&amp;hairsp;จากการรันโค้ดที่เขียนด้วย machine language โดยตรงนั่นเอง&lt;/p&gt;&lt;hr /&gt;&lt;h2&gt;&lt;a class="headeranchor" id="thingthaay"&gt;&lt;/a&gt;ทิ้งท้าย&lt;a class="headerlink" href="#thingthaay" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;คำว่า &amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; และ &amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp; ไม่ใช่คำขั้วตรงข้ามกัน&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ที่ผ่านมา เราพยายามตั้งคำถามและตอบคำถามที่มีลักษณะ binary&lt;label for="sidenote-7feb1e4b7880" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b7880" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
    หมายถึงการมองโลกว่าบางอย่างมีแค่สองทางเลือก ไม่อย่างใดก็อย่างหนึ่ง&lt;/span&gt;
โดยไม่ได้เข้าใจบริบทว่าของบางอย่างมันไม่ได้อยู่ตรงข้ามกันแบบ binary อย่างที่เราตั้งสมมติฐานไว้&lt;/p&gt;&lt;p&gt;เพื่อขยายความตรงประเด็นนี้ มาดูกันว่าเรา compile หรือ interpret โค้ดกันไปทำไม&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;เรา &amp;hairsp;&lt;strong&gt;compile&lt;/strong&gt;&amp;hairsp; โค้ดไปเพื่อ&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ทำให้โค้ดสามารถนำไปรันใน platform ต่าง&amp;hairsp;ๆ ได้&lt;/li&gt;&lt;li&gt;ช่วย optimize โค้ดให้โปรแกรมทำงานได้อย่างมีประสิทธิภาพมากขึ้น&lt;/li&gt;&lt;li&gt;ช่วยตรวจสอบความถูกต้องโปรแกรมในรูปแบบต่าง&amp;hairsp;ๆ เช่น type checking เป็นต้น&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;เรา &amp;hairsp;&lt;strong&gt;interpret&lt;/strong&gt;&amp;hairsp; โค้ดไปเพื่อ&amp;hairsp;… เอ่อ&amp;hairsp;… ก็รันโปรแกรมไง&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;เมื่อพิจารณา implementation ของภาษาโปรแกรมภาษาหนึ่ง&amp;hairsp;ๆ 
เราจะพบว่า อาจมีบางขั้นตอนเป็นการ compile และบางขั้นตอนเป็นการ interpret ก็ได้&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
ยิ่งไปกว่านั้น บาง implementation ก็มีลักษณะเป็นลูกผสมที่มีขั้นตอนการ compile ผสมกับการ interpret โค้ด
เช่น just-in-time (JIT) compiler เป็นต้น&lt;/p&gt;&lt;p&gt;จากที่เราพยายามพูดถึงคำว่า compile หรือ interpret จะเห็นได้ว่าการใช้คำสองคำนี้มีความกำกวม 
ซึ่งผู้เขียนไม่ได้ต้องการรณรงค์ว่าเราควรใช้คำต่าง&amp;hairsp;ๆ ให้ถูกต้อง
มิหนำซ้ำ ความคลุมเครือของภาษาก็มีประโยชน์ของมันเอง&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
เพียงแต่การศึกษาเกี่ยวกับ concept หรือนิยามนั่นก่อให้เกิดการพูดคุยกันที่น่าสนใจ
จนกลายมาเป็นบทความนี้ครับ&lt;/p&gt;&lt;h2&gt;&lt;a class="headeranchor" id="side-story"&gt;&lt;/a&gt;Side Story&lt;a class="headerlink" href="#side-story" title="Permalink to this headline"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ในช่วงหลายเดือนที่ผ่านมา ผู้เขียนได้เว้นว่างจากการเขียน blog ไป
เนื่องจากพบว่าเครื่องมือในการสร้างเว็บไซต์เดิม ไม่ตอบโจทย์ความต้องการ (ที่เรื่องมากสุด&amp;hairsp;ๆ) ของผู้เขียน&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
จึงได้มีความพยายามที่จะย้ายสำมโนครัวจาก GatsbyJS มายัง Pelican ในโลก Python&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
สิ่งที่ได้มีการปรับปรุง ประกอบได้ด้วย&lt;/p&gt;&lt;ol&gt;&lt;li&gt;การแทรก sidenote&lt;label for="sidenote-7feb1e4b7bb0" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b7bb0" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;ก็ข้อความแบบนี้นี่แหละ&lt;/span&gt;&lt;/li&gt;&lt;li&gt;การระบายสีพื้นหลังของโค้ดบางบรรทัด เพื่อเน้นส่วนสำคัญ&lt;/li&gt;&lt;li&gt;การเพิ่ม diff view เพื่อแสดงการเปลี่ยนแปลงของโค้ดจากเวอร์ชันหนึ่งสู่เวอร์ชันถัดไปแบบ incremental
        (สามารถดูตัวอย่างได้จาก&lt;a href="/posts/python-iterables-part-2-prepare-your-iterables"&gt;บทความที่แล้ว&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;&lt;p&gt;ผู้เขียนได้สร้าง text pre-processor ขึ้นมาตัวหนึ่ง เพื่อทำให้การเขียนบทความมีความยืดหยุ่นสูงขึ้น&lt;label for="sidenote-7feb1e4b7c40" class="margin-toggle sidenote-number"&gt;&lt;/label&gt;&lt;input type="checkbox" id="sidenote-7feb1e4b7c40" class="margin-toggle"/&gt;&lt;span class="sidenote"&gt;
            ตอนนี้โปรเจคนี่ยังอยู่ในระยะตั้งไข่ รอจนโปรเจคนี้เติบโตเต็มวัยแล้วจะมาเขียนถึงในอนาคต&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
            ตอนนี้อ่านรายละเอียดได้ที่&lt;a href="https://github.com/abhabongse/paxter/"&gt;หน้า GitHub ของโปรเจค Paxter&lt;/a&gt;
            &lt;/span&gt;&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
        ยกตัวอย่างเช่น ผู้เขียนสามารถประกาศค่าและฟังก์ชันต่าง&amp;hairsp;ๆ
        ด้วยภาษา Python และใช้งานภายในบทความเดียวกันได้เลย ดังนี้&lt;/p&gt;&lt;div class="highlight"&gt;&lt;div class="highlight-wrapper"&gt;&lt;table class="highlight-table"&gt;&lt;tbody&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;&lt;span class="o"&gt;@!##{&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;emph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"&amp;lt;em&amp;gt;&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;lt;/em&amp;gt;"&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"John"&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class="n"&gt;ๆ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&amp;amp;hairsp;ๆ'&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;&lt;span class="o"&gt;}##&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;My name is &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nf"&gt;name&lt;/span&gt; and &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nf"&gt;emph&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;I was &lt;span class="o"&gt;@{&lt;/span&gt;age - 1&lt;span class="o"&gt;}&lt;/span&gt; years old last year&lt;span class="o"&gt;}&lt;/span&gt;.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;ไม่ต้องเถียงกันว่าไม้ยมกต้องมีเว้นวรรคข้างหน้า 1 เคาะหรือไม่&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;ในเมื่อเราเลือกปรับขนาดของเว้นวรรคได้สบาย&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nf"&gt;ๆ&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;ซึ่งจะให้ผลลัพธ์เป็น&lt;/p&gt;&lt;div class="highlight"&gt;&lt;div class="highlight-wrapper"&gt;&lt;table class="highlight-table"&gt;&lt;tbody&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;My name is John and &amp;lt;em&amp;gt;I was 20 years old last year&amp;lt;/em&amp;gt;.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;ไม่ต้องเถียงกันว่าไม้ยมกต้องมีเว้นวรรคข้างหน้า 1 เคาะหรือไม่&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class="highlight-line-noop"&gt;&lt;td&gt;&lt;pre&gt;ในเมื่อเราเลือกปรับขนาดของเว้นวรรคได้สบาย&amp;amp;hairsp;ๆ&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;โปรดอ่านรายละเอียดเพิ่มเติมเกี่ยวกับเว็บไซต์นี้ได้ท้ายหน้า &lt;a href="/pages/about"&gt;about&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ขอขอบคุณผู้อ่านที่สละเวลามาอ่านบล็อกที่เขียนอะไรก็ไม่รู้&lt;span style="padding-left: 0.8rem;"&gt;&lt;/span&gt;
และขอขอบคุณผู้เสียสละ (โดยเฉพาะคุณ&amp;hairsp;สรวีย์&amp;hairsp;และคุณ&amp;hairsp;กันตภณ) 
ที่ช่วยอ่านต้นฉบับให้และ feedback จนได้บทความนี้ออกมาครับ&lt;/p&gt;&lt;p&gt;&amp;#8203;&lt;small&gt;
ป.ล. นี่อย่าให้เริ่มพูดถึงคำว่า functional, imperative, declarative, object-oriented, 
yadda– yadda– yadda– อะไรพวกนี้อีกนะ 
&lt;/small&gt;&lt;/p&gt;</content><category term="coding"></category><category term="programming languages"></category></entry></feed>